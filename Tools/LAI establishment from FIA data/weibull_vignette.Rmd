---
title: "NECN Weibull establishment parameters"
author: "Sam Flake"
date: "2024-08-30"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# LAI establishment curves

NECN v7 uses a modified Weibull curve to describe species shade preferences, 
replacing the clunky LAI table that was found in the NECN text input file in previous
versions. The LAI table was based on expert judgment, not data, and applied the same discontinuous
LAI breaks to all species. The new Weibull parameters are designed to be 1) more
accurate and customizable to each species, and 2) parameterized from data. 

This script has an example for how to parameterize the Weibull establishment curves
for two species. I recommend, instead of running this Rmd, look at the file ```weibull_params_example.R```. For a more detailed script (more similar to what you would need for a real NECN model), see ```get_weibull_params_from_fia_all_data.R```. That script has more options to include additional species, deal with rare species, and choose how the curves are fit. It should be pretty much plug-and-play with new species or study areas with a little modification (the species choices, matching them up to FIA SPCDs, and your LAI parameters from the NECN functional table file).


## Establishment in NECN and a little Bayesian tangent
During the reproduction phase of NECN, sites are evaluated for whether or not a new cohort can be recruited there using several criteria. The first hurdle which must be passed is whether there is enough light. For each species, the LAI of the site determines the probability that a recruit can establish there (this is what the LAI establishment table and the Weibull parameters determine). So, what NECN needs, is a way to represent the probability of recruitment given the LAI of the site, or p(recruit|LAI).

The way I've gone about doing this is by using inventory data from the USFS Forest Inventory and Analysis (FIA) project. For each species, I assume that the probability of recruitment at a given LAI value is related to the probability of the FIA project finding a seedling in a plot of that LAI -- it's a little different, but it should be strongly and directly related. The easiest way to calculate something related to establishment and LAI is to find where all the seedlings of a species are located, and look at the LAI of those sites. However, instead of giving us p(recruit|LAI), this gives us p(LAI|recruit) -- what is the probability of a value of LAI, given that there are seedlings there? 

While p(LAI|recruit) isn't quite right, we can relate it to p(recruit|LAI) by using Bayes' theorem:

p(recruit|LAI) = p(LAI|recruit) * p(recruit) / p(LAI)

While I don't use a Bayesian analysis here formally, I find the logic compelling -- the probability of recruitment given LAI is related to the histogram of LAIs where a seedling is found, by: 1) the landscape distribution of LAI (what is the probability of a given LAI?), and 2) the fecundity of the species (what is the probability of recruitment?).

Hopefully this motivating logic is apparent in the script below, when we get to the steps that scale the probability of recruitment to set the max p(recruit) equal for each species (which allows the area under the curve, or fecundity, to differ among species) and when we limit the landscape from which we sample (accounting for the distribution of LAI).

## Weibull overview

The Weibull distribution is a probability distribution function described by two parameters, a shape parameters and a scale parameter. It is great for distributions that are always positive and have long right tails -- like the typical distribution of leaf area index on a landscape. By changing the shape and scale parameters, we can get a wide variety of distributions, from a really shade-intolerant species with shape parameter < 1, to a shade-tolerant with a shape parameter around 2. 

It has the following equation:

y = (a/b) * ((X/b)^(a-1)) * exp(- (X/b)^a)

where a is the shape parameter and b is the scale parameter. In our case, X is plot-level LAI.

I've also modified the equation to allow for what I'm calling location and adjustment parameters, c and d. If you use these, then the curve is not describing a PDF anymore, just a Weibull-ish curve that might fit your data better. The area under the curve if you're using c or d will probably not be 1, so some species might have greate reproductive success than others -- this may be good or bad, depending on your needs. 

y = (((a/b) * ((lai/b)^(a-1)) * exp(- (lai/b)^a)) + c) * d

Here's a set of 2-parameter Weibull distributions with varying shape parameters and scale = 1.


```{r, echo=FALSE, fig.dim=c(4,4), message=FALSE}

shapes <- c(0.1, 0.5, 0.9, 1, 1.5, 2, 5)
pal <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

x <- seq(0, 10, length.out = 100)

plot(NA, xlim = c(0,10), ylim = c(0,1))
for(i in 1:length(shapes)){
  y <- dweibull(x, shape = shapes[i], scale = 1)
  lines(y ~ x, type = "l", col = pal[i])
}
legend(x = 6, y = 0.7, cex = 0.7, legend = paste0("shape = ", shapes), lty = 1, col = pal[1:length(shapes)])


```


And here's the same with shape = 1 and scale varying.


```{r, echo=FALSE, fig.dim=c(4,4), message=FALSE}

scales <- c(0.1, 0.5, 0.9, 1, 1.5, 2, 5)
pal <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

x <- seq(0, 10, length.out = 100)

plot(NA, xlim = c(0,10), ylim = c(0,1))
for(i in 1:length(scales)){
  y <- dweibull(x, shape = 1, scale = scales[i])
  lines(y ~ x, type = "l", col = pal[i])
}
legend(x = 6, y = 0.7, cex = 0.7, legend = paste0("scale = ", scales), lty = 1, col = pal[1:length(scales)])


```

Here's a Weibull curve with shape = 2 and scale = 1.5, with c varying:

```{r, echo=FALSE, fig.dim=c(4,4), message=FALSE}

a <- 2
b <- 1.5
c <- c(0, 0.1, 0.2, 0.3, 0.4, 0.5)
d <- 1


scales <- c(0.1, 0.5, 0.9, 1, 1.5, 2, 5)
pal <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

x <- seq(0, 10, length.out = 100)

plot(NA, xlim = c(0,10), ylim = c(0,1))
for(i in 1:length(c)){
  y <- (((a/b) * ((x/b)^(a-1)) * exp(- (x/b)^a)) + c[i]) * d
  lines(y ~ x, type = "l", col = pal[i])
}
legend(x = 6, y = 0.7, cex = 0.7, legend = paste0("c = ", c), lty = 1, col = pal[1:length(c)])


```


And here's what the d parameter does, again with shape = 2 and scale = 1.5:

```{r, echo=FALSE, fig.dim=c(4,4), message=FALSE}

a <- 2
b <- 1.5
c <- 0
d <- c(0.5, 0.9, 1, 1.3, 2, 5)


scales <- c(0.1, 0.5, 0.9, 1, 1.5, 2, 5)
pal <- c("#999999", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

x <- seq(0, 10, length.out = 100)

plot(NA, xlim = c(0,10), ylim = c(0,1))
for(i in 1:length(d)){
  y <- (((a/b) * ((x/b)^(a-1)) * exp(- (x/b)^a)) + c) * d[i]
  lines(y ~ x, type = "l", col = pal[i])
}
legend(x = 6, y = 0.7, cex = 0.7, legend = paste0("d = ", d), lty = 1, col = pal[1:length(d)])


```

So there's a variety of shapes we can fit using Weibull, which solves one issue with the LAI tables, but we still need to be able to parameterize them from real data.

# Paramaterizing light preferences for species

This script has several steps:

1. import and wrangle FIA data for plots, trees, seedlings, and sitetrees
2. assemble FIA plots into age/species cohorts like LANDIS-II
3. estimate leaf area for plots using the same algorithm as NECN
4. get amount of regeneration per plot per species
5. fit distributions to regen~LAI values using nonlinear least squares


## Step 0: Loading libraries and functions

```{r echo=FALSE, warning=FALSE, message=FALSE}

#libraries
library("tidyverse", quietly = TRUE)
library("rFIA", quietly = TRUE)
library("nls2", quietly = TRUE)
library("minpack.lm", quietly = TRUE)
library("sf", quietly = TRUE)
```

We also have a big functiont that fits the weibull parameters, ```fit_weibull()```, but I won't put it here -- take a look at get_weibull_params_from_fia_all_data.R for details. 

```{r echo = FALSE, message=FALSE}
fit_weibull <- function(dat, lower = c(-Inf, -Inf, 0, 0), upper = c(Inf, Inf, Inf, 10), use_c_d = "both") {
  #function to fit the weibull distribution curve to binned data using NLS
  #This function fits the Weibull curve in two steps: one to get starting values,
  # and another iterative curve-fitting function. 
  # There are some options for whether you want to include the location (c) parameter
  # or adjustment (d) parameter. Those either allow for a floor greater than 0, or 
  # scale the whole curve up to allow greater reproduction across the board.
  
  
  #you might have to play with these starting values
  pars <- expand.grid(a=seq(0.1,10, len=50), #shape
                      b=seq(0.1, 20, len=10), #scale
                      c = 0, #threshold parameter; this sets the "floor" for the curve,
                      # the y-intercept for shape parameter > 1
                      # or asymptote for low values of shape parameters
                      d=seq(0.1, 20, len = 20) #removed d parameter, which scales everything vertically
                      #it does allow better fit but harder to converge
  )
  
  
  # a floor could be set by replacing c with a constant, rather than 
  # estimating it, though this could cause issues with convergence.
  # first round to get approximate starting values
  if(use_c_d == "both") formula <- prop_present ~ (((a/b) * ((lai/b)^(a-1)) * exp(- (lai/b)^a)) + c) * d
  if(use_c_d == "c"){
    formula <- prop_present ~ (((a/b) * ((lai/b)^(a-1)) * exp(- (lai/b)^a)) + c)
    pars <- pars[,c(1:3)]
    lower = lower[c(1:3)]
    upper = upper[c(1:3)]
  } 
  if(use_c_d == "d") {
    formula <- prop_present ~ (((a/b) * ((lai/b)^(a-1)) * exp(- (lai/b)^a))) * d
    pars <- pars[,c(1,2,4)]
    lower = lower[c(1,2,4)]
    upper = upper[c(1,2,4)]
  }
  if(use_c_d == "neither"){
    formula <- prop_present ~ (((a/b) * ((lai/b)^(a-1)) * exp(- (lai/b)^a)))
    pars <- pars[,c(1,2)]
    lower = lower[c(1,2)]
    upper = upper[c(1,2)]
  }
  
  res <- nls2(formula, 
              data=dat,
              start=pars, 
              algorithm='brute-force',
              upper = upper,
              lower = lower,
              weights = dat$n_plots_bin)
  
  #get better estimates using minpack
  res1 <- nlsLM(formula, 
                data=dat,
                start=as.list(coef(res)),
                upper = upper,
                lower = lower,
                weights = dat$n_plots_bin)
  
  #sometimes c will be negative, which would allow seedlings to sometimes be negative.
  #If that happens, refit the model with c = 0
  if(use_c_d %in% c("both", "c") & coef(res1)[3] < 0) {
    res1 <- nlsLM(prop_present ~ ((a/b) * ((lai/b)^(a-1)) * exp(- (lai/b)^a)),
                  data=dat,
                  start=as.list(coef(res)[c(1,2)]))
  }
  
  
  return(res1)
}

#options
options(scipen = 999)

```

We also have a few options that will make sense once we get through the script. 
Mostly, we need to define what makes a plot "available" for recruitment, so we're
not including a bunch of plots out of the range of a species where we wouldn't expect
to find them. Don't worry about these for now, but they're in the script for when you need them later.

```{r }
#should we restrict our analysis to plots that are near seedlings, near adult trees, or unrestricted?
#this is by far the slowest part of the script
range_method <- "seedling" #"seedling" or "adult"; other options skip this step and use all the data from the chosen states
#range buffer size -- how many meters can plots be from seedlings to count in the calculation?
range_buffer <- 10000
#should maximum suitability be set to 1 and everything scaled to match? This will (almost?)
# always increase total suitable light levels and thus regeneration
scale_max_p <- TRUE
#should the area under the curve be set to 1 for all species? This will cancel out
# differences in abundance/fecundity among species. Probably not recommended if you hae
# a lot of range-restricted species, unless you're using the range_method option above.
# But this is very much recommended if you're wanting to fit a true Weibull PDF where AUC = 1 
# (i.e. using use_c_d == "neither")
set_auc_to_1 <- FALSE
#what formula should we use? See above equation fit_weibull. For a regular Weibull PDF,
# set use_c_d = "neither", to only use the shape and scale parameters. Otherwise,
# you can use the c parameter to translate the whole curve up or the d parameter to stretch the
# whole curve. This gives more flexibility in the kinds of shapes that can be fit,
# and allows for the area under the curve to be greater than 1.
use_c_d <- "d"

```

# Step 1: Wrangling data

I've got some FIA data pre-wrangled for us. It's FIA plots randomly selected from Michigan and Minnesota, and we're looking at establishment of balsam fir (Abies balsamea) and quaking aspen (Populus tremuloides). We need tree data to estimate LAI and seedling data to look at recruitment. We also need the sitetree table to make some estimates of tree ages.

```{r}
#species reference data
sp_ref <- read.csv("./example_data/REF_SPECIES.csv")

trees <- read.csv("./example_data/trees.csv")
plot <- read.csv("./example_data/plot.csv")
seedlings <- read.csv("./example_data/seedlings.csv")
sitetrees <- read.csv("./example_data/sitetrees.csv")
```

Here's what our plots look like:

```{r echo = FALSE, message=FALSE}
plot_sf <- plot %>%
  sf::st_as_sf(coords = c("LON", "LAT"), crs = "EPSG:4326")
plot(plot_sf["ELEV"])

```


# Step 2: Crosswalk LANDIS-II and FIA


this is the functional table and species table from your NECN project. We need them for a few things, like calculating LAI and crosswalking LANDIS-II species names and FIA SPCDs

```{r}
func_table <- read.csv("./example_data/NECN_Functional_Table_inv_moisture.csv")
sp_table <- read.csv("./example_data/NECN_Spp_Table_inv_necn7.csv") %>%
  left_join(func_table, by = "FunctionalGroupIndex") 
```

We need to assign each FIA species group a value for KLAI and MaximumLAI.
You may have a lot of species in FIA that aren't in your LANDIS project; I'd suggest
just coming up with a catchall functional group for those and putting all the 
extra SPGRPCDs in there. Multiple SPGRPCDs might match each NECN functional group,
and some FGs might not have a corresponding SPGRPCD if there are no FIA species 
that match. That's fine.
```{r}
spgrp_lai <- data.frame(SPGRPCD = unique(trees$SPGRPCD),
                        FunctionalGroupIndex = numeric(length(unique(trees$SPGRPCD)))) %>%
  arrange(SPGRPCD) %>%
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(5,4, 3, 2), 1, FunctionalGroupIndex))%>% #jack and red pine
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(6), 2, FunctionalGroupIndex))%>%   #balsam fir and white spruce
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(9), 3, FunctionalGroupIndex))%>%    #eastern white pine
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(36, 35), 4, FunctionalGroupIndex)) %>% #black spruce
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(7), 5, FunctionalGroupIndex)) %>% #tamarack, ceder
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(30, 31, 33, 42), 6, FunctionalGroupIndex)) %>% #northern hardwoods
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(37, 38, 41), 7, FunctionalGroupIndex)) %>% #aspen
  mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(25, 26, 28, 29, 27, 32, 43, 40, 39, 55), 8, FunctionalGroupIndex)) %>% #southern harwoods
  # mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(), 9, FunctionalGroupIndex)) %>% #wet broadleaf 
  # mutate(FunctionalGroupIndex = ifelse(SPGRPCD %in% c(), 10, FunctionalGroupIndex)) %>% #shrubs
  left_join(func_table %>% dplyr::select(FunctionalGroupIndex, KLAI, MaximumLAI))

#here, we're just doing ABBA and POTR, not all the species
spp_to_use_all <- c("ABBA", "POTR5") #sp_table$SpeciesCode
```


We need to get SPCD for each species. This will be different depending on how the species are named,
but we want a crosswalk from the names used in LANDIS to FIA SPCD somehow
In this project, I used the USDA PLANTS symbol, which is found in the FIA species reference table
to crosswalk to FIA species code. We want a column of SpeciesCode that is your 
LANDIS species identifier, and a column of SPCD that is the FIA species number.

```{r}
sp_ref$SpeciesCode <- sp_ref$SPECIES_SYMBOL
spp_crosswalk <- sp_ref[sp_ref$SPECIES_SYMBOL %in% spp_to_use_all, ] %>%
  dplyr::arrange(SPECIES_SYMBOL) %>%
  dplyr::select(SpeciesCode, SPCD)


# for seedlings, some species don't have enough to get good estimates. This table
# combines several SPCD for each species (e.g., uncommon Populus spp.) to 
# improve parameter estimates for rare species. You have to do this by hand for each
# species you're modeling. Here it's simple because I'm just using two common species
spp_crosswalk_combine <- tibble(SpeciesCode = spp_to_use_all,
                                SPCD = list(12, #Balsam fir
                                            746 #quaking aspen
                                ))

spp_to_use <- spp_crosswalk$SpeciesCode
spcd_to_use <- spp_crosswalk$SPCD
all_spcd <- unique(trees$SPCD)
```


# Step 3: Calculate per-tree LAI contribution and plot-level LAI

I'm using the same logic that NECN does to estimate plot-level LAI, so that we don't have mismatches when we apply the parameters we're generating to an NECN model. So we need to get ages and biomass for cohorts, just like LANDIS-II.

```{r}
#we need to make sure the trees have ages so we can bin them
enough_trees <- table(sitetrees$SPCD) %>% `[`(which(table(sitetrees$SPCD) > 100)) %>% names()

#make an age model for each species -- you could do this however you want; this is a quick and dirty
# cubic regression for each species, and lumping all rare species into one model
age_model <- lm(log(AGEDIA) ~ poly(log(DIA), 3)*as.factor(SPCD), 
                data = sitetrees[!is.na(sitetrees$DIA) & !is.na(sitetrees$AGEDIA) & sitetrees$SPCD %in% enough_trees, ])
age_model2 <- lm(log(AGEDIA) ~ poly(log(DIA), 3), 
                 data = sitetrees[!is.na(sitetrees$DIA) & !is.na(sitetrees$AGEDIA), ])

#asign ages to trees based on species and diameter
trees <- trees %>%
  mutate(PLOT.YEAR = paste(PLT_CN, INVYR, sep=".")) %>%
  right_join(., plot, by = c("PLT_CN" = "CN")) %>%
  dplyr::mutate(DIA_cm = DIA * 2.54,
                HT_m = HT / 3.3808) %>%
  dplyr::filter(STATUSCD == 1) %>%
  dplyr::left_join(spgrp_lai)

for(i in 1:length(all_spcd)){
  
  spcd = all_spcd[i]
  sp = spp_crosswalk[match(spcd, spp_crosswalk$SPCD), "SpeciesCode"]
  
  if(spcd %in% enough_trees){
    
    trees[trees$SPCD == spcd, "TOTAGE2"] <- exp(predict(age_model,
                                                        newdata = trees[trees$SPCD == spcd, ]))
    
  } else{
    trees[trees$SPCD == spcd, "TOTAGE2"] <- exp(predict(age_model2,
                                                        newdata = trees[trees$SPCD == spcd, ]))
    
  }
}

trees$age <- ifelse(is.na(trees$TOTAGE), trees$TOTAGE2, trees$TOTAGE)
trees$age <- ifelse(trees$age > 500, 500, trees$age)
breaks <- seq(0, max(trees$age, na.rm = TRUE) + (10 - max(trees$age, na.rm = TRUE) %% 10), by = 5)
trees$age_bin <- base::cut(trees$age, breaks = breaks, labels = breaks[-1], right = TRUE)

#use the NECN LAI calculation to get plot-level LAI
trees_bin <- trees %>%
  group_by(PLOT.YEAR, SPCD, age_bin) %>%
  summarise(cohort_biomass = sum(CARBON_AG/0.47, na.rm = TRUE) * 0.11, #sum biomass and convert to g m-2
            KLAI = KLAI[1],
            MaximumLAI = MaximumLAI[1]) %>%
  mutate(LAI_tree = MaximumLAI * cohort_biomass/(KLAI + cohort_biomass))

#calculate leaf area index per plot
plot_leaf_area <- trees_bin %>%
  group_by(PLOT.YEAR) %>%
  #m2 per tree * trees per acre * acre per m2 = meters squared leaf area per meter squared ground
  summarise(LAI = sum(LAI_tree)) %>%
  filter(!is.na(LAI) & !is.infinite(LAI)) %>%
  filter(LAI < 20)

hist(plot_leaf_area$LAI)
```

# Step 4:  See where seedlings are present and which plots they could be present

We could be done at this point, if we wanted -- just join the seedlings to the LAI table and make a histogram and call it good. I think it's working better to go a little further, and spatially restrict the plots we're considering as potential for recruitment. 

First let's get how many seedlings we have per plot

```{r}

# get seedlings
seedlings <- seedlings %>%
  mutate(PLOT.YEAR = paste(PLT_CN, INVYR, sep="."),
         TPA_UNADJ = ifelse(is.na(TPA_UNADJ), 0, TPA_UNADJ)) %>%
  filter(PLOT.YEAR %in% plot_leaf_area$PLOT.YEAR) %>% #filter out plots with bad LAI data, inappropriate COND, etc.
  # filter(TOTAGE <= 5) %>% #only useful in RMRS zone, and only collected fora  subset of trees
  group_by(PLOT.YEAR) %>%
  mutate(SEEDLING_COUNT = sum(TPA_UNADJ)) %>%
  slice_head(n = 1)

hist(seedlings$SEEDLING_COUNT)
```


Next we need to figure out which plots are available for recruitment for each species. Here, I'm restricting the available plots to those within 10 km of a seedling, as a way to represent the geographical range of the species' natural recruitment. There's other options in the other script. You could get very fancy with this part if you wanted to.

First let's do this with balsam fir to demonstrate:
```{r}
  SPCD <- spp_crosswalk_combine[[1, "SPCD"]][[1]]
  
  seedling_sub <- seedlings[seedlings$SPCD %in% SPCD,]
  
  plot_sf <- plot  %>%
    sf::st_as_sf(coords = c("LON", "LAT")) %>%
    st_as_sf %>%
    sf::st_set_crs("EPSG:4326") %>%
    sf::st_transform("EPSG:5070") %>%
    mutate(PLOT.YEAR = paste(CN, INVYR, sep="."))
    
  seedling_sf <- left_join(seedling_sub, select(plot, CN, LAT, LON), by = c("PLT_CN" = "CN")) %>%
    sf::st_as_sf(coords = c("LON", "LAT"))%>%
    sf::st_set_crs("EPSG:4326") %>%
    sf::st_transform("EPSG:5070")
  
  #create a zone within buffer distance of seedlings
  seedling_buffer <- sf::st_buffer(seedling_sf, range_buffer) %>% 
    st_union() %>% 
    st_as_sf()
  
  #figure out which plots are in range
  plot_sf$in_range <- lengths(st_within(plot_sf, seedling_buffer))
    
```

Here's what all of our plots look like:

```{r}
plot(st_geometry(plot_sf))
```

But here's where balsam fir regeneration occurs -- just the Upper Penninsula of Michigan and northern Minnesota, mostly. This is the 10 km buffer we created around all the plots with balsam fir seedlings.

```{r}
plot(st_geometry(plot_sf))
plot(st_geometry(seedling_buffer), col = "red", add = TRUE)
```

So we want to just use a subset of the plots:

```{r}
plot(plot_sf["in_range"])
```
When we sum up the number of seedlings in each plot, we get something like this, where we have a column of plot IDs, a column of LAI for each plot, and then the number of seedlings for each species (in this case, just balsam fir). We've counted seedlings when they're present, assigned a 0 if the plot is in range and has no seedlings, and an NA if it's out of range.

```{r echo = FALSE}
  Table <- seedlings[seedlings$SPCD %in% SPCD,]

  Sums <- aggregate(Table$TREECOUNT, by=list(PLOT.YEAR = Table$PLOT.YEAR), FUN=sum)
  Sums$x <- ifelse(is.na(Sums$x), 0, Sums$x)
  colnames(Sums) <- c("PLOT.YEAR", spp_to_use[1])
  
  #plots without seedlings get a 0, plots out of range get an NA
  plot_leaf_area <- left_join(plot_leaf_area, Sums, by = "PLOT.YEAR") %>%
    mutate(across(spp_to_use[1], ~ ifelse(is.na(.), 0, .))) %>%
    mutate(across(spp_to_use[1], ~ ifelse(PLOT.YEAR %in% filter(plot_sf, in_range == 1)$PLOT.YEAR,
                                          .,
                                          NA)))
  
  head(plot_leaf_area)

```



```{r echo=FALSE}
spp_to_use2 <- spp_to_use[which(spp_to_use %in% names(plot_leaf_area))]
```

# Step 5: Fit a distribution to the seedling data

Now that we know the LAI for a bunch of plots and whether or not there's seedlings present in those plots, we can start to explore how seedlings are distributed with respect to LAI and try to fit distributions to that data. Here, I've binned LAI into 30 equal bins, and, for each bin, found what proportion of the plots have balsam fir seedlings:

```{r echo = FALSE}
#make histogram for proportion
nBins <- 30
minLAI <- 0.05
plot_seedling_histogram <- plot_leaf_area %>%
  tidyr::pivot_longer(cols = all_of(spp_to_use2),
                      names_to = "Species",
                      values_to = "Count") %>%
  mutate(LAI = ifelse(LAI < minLAI, minLAI, LAI)) %>%
  mutate(lai_bin = base::cut(LAI, breaks = nBins),
         present = ifelse(Count>0, 1, 0)) %>%
  group_by(Species, lai_bin) %>%
  summarise(n_present = sum(present, na.rm = TRUE),
            n_plots_bin = sum(!is.na(present)),
            prop_present = n_present / n_plots_bin) %>%
  ungroup() %>%
  group_by(Species) %>%
  mutate(prop_present = ifelse(is.na(prop_present), 0, prop_present)) %>%
  mutate(lai = strsplit(as.character(lai_bin), split = ",") %>% #calculate the midpoint of the bin
           map(., .f = ~gsub("\\(|\\]", "", .)) %>%
           map(., .f = ~mean(as.numeric(.))) %>%
           unlist() %>%
           as.numeric()) %>%
  suppressMessages()
# if(set_auc_to_1) plot_seedling_histogram <- plot_seedling_histogram %>%
#   mutate(prop_present = prop_present / sum(prop_present, na.rm = TRUE)) #proportion of plots in the bin with seedlings
# if(scale_max_p) plot_seedling_histogram <- plot_seedling_histogram %>%
#   mutate(prop_present = prop_present * (1/max(prop_present, na.rm = TRUE))) #set the maximum prop_present to 1 
# #and scale everything to match

ggplot(plot_seedling_histogram, aes(x = lai, y = prop_present, color = Species)) +
  geom_line() +
  xlab(label = "Leaf Area Index") +
  ylab(label = "Proportion of plots with seedlings")

```

We can see that there's a peak in seedlings at around LAI = 4 or so, which is a little past the point where most sorts of forests' canopies have closed. This pattern of regeneration is what we expect from a shade-tolerant tree like balsam fir. There are still some seedlings in more open sites, perhaps advanced regeneration in a gap or just early colonists of a blowdown or fire. 

We might want to fiddle with this data some, depending on how our model is parameterized. We could set the sum of the area under the curve equal to 1, which would make this closer to a PDF, or we could scale the whole thing so that the maximum probability of finding a seedling is equal to 1, which more closely matches the behavior of the LAI-establishment tables from NECN v6.

```{r echo=FALSE}
plot_seedling_histogram2 <- plot_seedling_histogram %>%
  mutate(prop_present = prop_present / sum(prop_present, na.rm = TRUE)) %>%
  mutate(scaling = "AUC = 1")     #proportion of plots in the bin with seedlings
plot_seedling_histogram3 <- plot_seedling_histogram %>%
  mutate(prop_present = prop_present * (1/max(prop_present, na.rm = TRUE))) %>%
  mutate(scaling = "Max = 1")  #set the maximum prop_present to 1 and scale everything to match
plot_seedling_histogram_orig <- plot_seedling_histogram %>% mutate(scaling = "None")
  
all3 <- rbind(plot_seedling_histogram_orig, plot_seedling_histogram2, plot_seedling_histogram3)

ggplot(all3, aes(x = lai, y = prop_present, color = scaling)) +
  geom_line() +
  xlab(label = "Leaf Area Index") +
  ylab(label = "Proportion of plots with seedlings")

```

Note that things get a little funky at higher LAIs -- that's because there aren't that many plots there. We can account for that when we fit our distributions by including the number of plots in each bin as weights, which will downweight the highly variable right tail of that distribution and put more emphasis on fitting the left of the distribution where most of the data are. Here's how those weights look:

```{r echo=FALSE, message=FALSE, warning=FALSE}
plot(n_plots_bin ~ lai, 
     data = plot_seedling_histogram[plot_seedling_histogram$Species == "ABBA", ],
     xlab = "LAI",
     ylab = "Number of plots")
```

Now that we have the probability of finding a seedling at a given LAI, we can fit a curve to that data and generate the inputs we need for NECN. I've found that using that a, b, and d parameters works pretty well for this species, and I'll be using the version of the seedling data that scales the maximum p(seedling) to equal 1, so I can compare to the NECN v6 values more easily. 

```{r echo=FALSE, message=FALSE, warning=FALSE}
#set bounds to parameter estimates to send to the function that fits weibull parameters.
#bound the location parameter at 0 so that we don't get negative P_est.
#You could set other constraints if you're not getting realistic shapes
species_bounds <- tibble(Species = spp_to_use)
species_bounds$lower = list(c(-Inf, -Inf, 0, 0)) #lower and upper bounds for the shape, scale, location, and adjustment parameters
species_bounds$upper = list(c(Inf, Inf, Inf, 20))

#Only if needed: for some species, set the maximum shape parameter 
# to 1 to force a negative-exponential shape
species_bounds[species_bounds$Species %in% c("PIST"), ]$upper <- list(c(1, Inf, Inf, 20))

plot_seedling_histogram <- plot_seedling_histogram3

plot_seedling_histogram <- left_join(plot_seedling_histogram, species_bounds)

#fit the models using function above, and pull out the shape and scale  
#parameters with broom::tidy()
weibull_models <- plot_seedling_histogram %>%
  mutate(PLOT.LAI = ifelse(lai < 0.1, 0.1, lai)) %>%
  ungroup() %>%
  group_by(Species) %>%
  ungroup() %>%
  dplyr::nest_by(Species) %>%
  mutate(model = list(fit_weibull(data, data$lower[[1]], data$upper[[1]], use_c_d = use_c_d))) %>%
  mutate(shape = broom::tidy(model) %>% pluck(., 2, 1),
         scale = broom::tidy(model) %>% pluck(., 2, 2),
         location = ifelse(use_c_d == "d", 0, broom::tidy(model) %>% pluck(., 2, 3, .default = 0)), #sometimes c doesn't exist; set it to 0 in that case
         adjust = broom::tidy(model) %>% pluck(., 2, ifelse(use_c_d == "d", 3, 4), .default = 1)) #sometimes d doesn't exist; set it to 0 in that case

# weibull_models_max_1 <- weibull_models

#make a figure for each species with empirical data and distribution
#this is pretty gross looking but not that complicated really.
#We loop through each item of the list (.l), which loops us through each species,
#where we make a ggplot figure for each species
newdat <- list(lai = seq(0, 20, length.out = 100))
pmap(.l = list(dat = weibull_models$data, 
               sp = weibull_models$Species,
               mod = weibull_models$model),
     .f = function(dat, sp, mod){ 
       ggplot(data = dat, aes(x = lai, y = prop_present)) + 
         geom_point() + 
         ggtitle(label = sp) +
         geom_line(data = data.frame(pred = predict(mod, newdata = newdat),
                                     lai = newdat$lai),
                   aes(y = pred, x = lai))
     })
```

Let's compare this to a previous version of the model, based on parameters inherited from a previous model. Those parameters looked like this:
```
>> Shade	Max LAI
>> Class	
>> ------------------------------	
	1	  1 
	2	  2.5 
	3	  3.5 
	4	  6
	5	  8

LightEstablishmentTable	
					
>>	Spp Shade	Probability					
>>	Class		by Actual Shade					
>>	 -----------------------------					
>>		0	    1     2	    3	    4	    5
	1   1.0	  0.5   0.02	0.0	  0.0	  0.0
	2	  0.6	  1.0   0.5	  0.02	0.0	  0.0
	3	  0.01	0.6	  1.0	  0.5	  0.02	0.0
	4	  0.0	  0.01	0.6	  1.0	  0.5	  0.02
	5	  0.0	  0.0	  0.01	0.5	  1.0	  1.0
```

We had balsam fir as shade tolerance class 4, which means its recruitment would have peaked at LAI between 3.5 and 6. We can look at the FIA data and see that this is a little off. Let's plot the original LAI table values as blue horizontal lines, on top of the curve we just calibrated, and see how it compares.


```{r echo=FALSE, message=FALSE, warning=FALSE}

lai_table <- data.frame(start = c(0,1,2.5,3.5,6,8),
                        end = c(1,2.5,3.5,6,8,20),
                        val = c(0.0, 0.01, 0.6, 1, 0.5, 0.02))
dat = weibull_models$data[[1]]
sp = weibull_models$Species[[1]]
mod = weibull_models$model[[1]]

ggplot(data = dat, aes(x = lai, y = prop_present)) + 
         geom_point() + 
         ggtitle(label = sp) +
         geom_line(data = data.frame(pred = predict(mod, newdata = newdat),
                                     lai = newdat$lai),
                   aes(y = pred, x = lai)) +
  geom_segment(data = lai_table, aes(x = start, xend = end, y = val, yend = val), color = "blue")

mod_output <- dplyr::select(weibull_models, Species, shape, scale, location, adjust)

```

We're actually not that far off in this case -- the shape of the curve is similar, and the LAI of maximum recruitment success isn't that dissimilar. But we've now got a repeatable workflow, based on real data, that we can reference. We can quickly generate curves for new species rather than copying from projects from dissimilar areas.

As far as parameters go, we end up with a shape parameter of ```{r}mod_output[[1]]$shape```, a scale parameter of ```{r}mod_output[[1]]$scale```, and an adjust parameter of ```{r}mod_output[[1]]$adjust```. Because I set the script not to use the location parameter, it is set to 0 (so the right tail asymptotically approaches 0). The shape parameter greater than 1 means that the species has a peak in recruitment at LAI > 0; a really shade-intolerant species should have a negative-exponential shape, with shape parameter less than 1. Let's take a look at one and make sure that this all works like we expect.

### Adding a species
Let's do the same thing for a shade-intolerant species, quaking aspen. I'll just run through the whole script with both species, balsam fir (ABBA) and quaking aspen so we can compare.


```{r echo=FALSE, message=FALSE, warning=FALSE}

range_method <- "seedling"
scale_max_p <- TRUE
plot_leaf_area <- trees_bin %>%
  group_by(PLOT.YEAR) %>%
  #m2 per tree * trees per acre * acre per m2 = meters squared leaf area per meter squared ground
  summarise(LAI = sum(LAI_tree)) %>%
  filter(!is.na(LAI) & !is.infinite(LAI)) %>%
  filter(LAI < 20)


for (i in 1:nrow(spp_crosswalk)){
  range_method <- ifelse(is.na(range_method), "none", range_method)
  
  SPCD <- spp_crosswalk_combine[[i, "SPCD"]][[1]]
  
  seedling_sub <- seedlings[seedlings$SPCD %in% SPCD,]
  
  plot_sf <- plot  %>%
    sf::st_as_sf(coords = c("LON", "LAT")) %>%
    st_as_sf %>%
    sf::st_set_crs("EPSG:4326") %>%
    sf::st_transform("EPSG:5070") %>%
    mutate(PLOT.YEAR = paste(CN, INVYR, sep="."))
  
  if(range_method == "seedling"){
    
    seedling_sf <- left_join(seedling_sub, select(plot, CN, LAT, LON), by = c("PLT_CN" = "CN")) %>%
      sf::st_as_sf(coords = c("LON", "LAT"))%>%
      sf::st_set_crs("EPSG:4326") %>%
      sf::st_transform("EPSG:5070")
    
    #create a zone within buffer distance of seedlings
    seedling_buffer <- sf::st_buffer(seedling_sf, range_buffer) %>% 
      st_union() %>% 
      st_as_sf()
    plot_sf$in_range <- lengths(st_within(plot_sf, seedling_buffer))
    
  }else if(range_method == "adult"){
    plots_with_adults <- trees %>%
      filter(SPCD %in% SPCD) %>%
      filter(age > 20) %>% #pick an age at maturity to serve as a seed source
      `[`("PLT_CN") %>%
      unique()
    
    plot_adults <- plot[plot$CN %in% plots_with_adults$PLT_CN, ]  %>%
      sf::st_as_sf(coords = c("LON", "LAT")) %>%
      distinct(geometry) %>%
      st_as_sf %>%
      sf::st_set_crs("EPSG:4326") %>%
      sf::st_transform("EPSG:5070")
    
    plot_buffer <- sf::st_buffer(plot_adults, range_buffer) %>% 
      st_union() %>% 
      st_as_sf()
    plot_sf$in_range <- lengths(st_within(plot_sf, plot_buffer))
    
  }else{
    plot_sf$in_range <- 1
  }
  
  Table <- seedlings[seedlings$SPCD %in% SPCD,]
  
  if(nrow(Table) == 0) next #this can break the rest of the code, because further down expects a column for every species
  
  Sums <- aggregate(Table$TREECOUNT, by=list(PLOT.YEAR = Table$PLOT.YEAR), FUN=sum)
  Sums$x <- ifelse(is.na(Sums$x), 0, Sums$x)
  colnames(Sums) <- c("PLOT.YEAR", spp_to_use[i])
  
  #plots without seedlings get a 0, plots out of range get an NA
  plot_leaf_area <- left_join(plot_leaf_area, Sums, by = "PLOT.YEAR")
  plot_leaf_area <- plot_leaf_area%>%
    mutate(across(spp_to_use[i], ~ ifelse(is.na(.), 0, .))) %>%
    mutate(across(spp_to_use[i], ~ ifelse(PLOT.YEAR %in% filter(plot_sf, in_range == 1)$PLOT.YEAR,
                                          .,
                                          NA)))
  
  
}


spp_to_use2 <- spp_to_use[which(spp_to_use %in% names(plot_leaf_area))]

n_seedlings <- plot_leaf_area %>%
  tidyr::pivot_longer(cols = all_of(spp_to_use2),
                      names_to = "Species",
                      values_to = "Count") %>%
  group_by(Species) %>%
  summarize(total = sum(Count, na.rm = TRUE))

# write.csv(plot_leaf_area, file = paste("seedlings_with_leaf_area.csv", sep=""))

#-------------------------------------
# Finding proportion of each LAI bin with seedlings present

#make histogram for proportion
nBins <- 30
minLAI <- 0.05
plot_seedling_histogram <- plot_leaf_area %>%
  tidyr::pivot_longer(cols = all_of(spp_to_use2),
                      names_to = "Species",
                      values_to = "Count") %>%
  mutate(LAI = ifelse(LAI < minLAI, minLAI, LAI)) %>%
  mutate(lai_bin = base::cut(LAI, breaks = nBins),
         present = ifelse(Count>0, 1, 0)) %>%
  group_by(Species, lai_bin) %>%
  summarise(n_present = sum(present, na.rm = TRUE),
            n_plots_bin = sum(!is.na(present)),
            prop_present = n_present / n_plots_bin) %>%
  ungroup() %>%
  group_by(Species) %>%
  mutate(prop_present = ifelse(is.na(prop_present), 0, prop_present)) %>%
  mutate(lai = strsplit(as.character(lai_bin), split = ",") %>% #calculate the midpoint of the bin
           map(., .f = ~gsub("\\(|\\]", "", .)) %>%
           map(., .f = ~mean(as.numeric(.))) %>%
           unlist() %>%
           as.numeric())
if(set_auc_to_1) plot_seedling_histogram <- plot_seedling_histogram %>%
  mutate(prop_present = prop_present / sum(prop_present, na.rm = TRUE)) #proportion of plots in the bin with seedlings
if(scale_max_p) plot_seedling_histogram <- plot_seedling_histogram %>%
  mutate(prop_present = prop_present * (1/max(prop_present, na.rm = TRUE))) #set the maximum prop_present to 1 
#and scale everything to match

ggplot(plot_seedling_histogram, aes(x = lai, y = prop_present, color = Species)) +
  geom_line() +
  xlab(label = "Leaf Area Index") +
  ylab(label = "Proportion of plots with seedlings")


#set bounds to parameter estimates to send to the function that fits weibull parameters.
#bound the location parameter at 0 so that we don't get negative P_est.
#You could set other constraints if you're not getting realistic shapes
species_bounds <- tibble(Species = spp_to_use)
species_bounds$lower = list(c(-Inf, -Inf, 0, 0)) #lower and upper bounds for the shape, scale, location, and adjustment parameters
species_bounds$upper = list(c(Inf, Inf, Inf, 20))

#Only if needed: for some species, set the maximum shape parameter 
# to 1 to force a negative-exponential shape
species_bounds[species_bounds$Species %in% c("POTR5"), ]$upper <- list(c(1, Inf, Inf, 20))

plot_seedling_histogram <- left_join(plot_seedling_histogram, species_bounds)

#fit the models using function above, and pull out the shape and scale  
#parameters with broom::tidy()
weibull_models <- plot_seedling_histogram %>%
  mutate(PLOT.LAI = ifelse(lai < 0.1, 0.1, lai)) %>%
  ungroup() %>%
  group_by(Species) %>%
  ungroup() %>%
  dplyr::nest_by(Species) %>%
  mutate(model = list(fit_weibull(data, data$lower[[1]], data$upper[[1]], use_c_d = use_c_d))) %>%
  mutate(shape = broom::tidy(model) %>% pluck(., 2, 1),
         scale = broom::tidy(model) %>% pluck(., 2, 2),
         location = ifelse(use_c_d == "d", 0, broom::tidy(model) %>% pluck(., 2, 3, .default = 0)), #sometimes c doesn't exist; set it to 0 in that case
         adjust = broom::tidy(model) %>% pluck(., 2, ifelse(use_c_d == "d", 3, 4), .default = 1)) #sometimes d doesn't exist; set it to 0 in that case


#make a figure for each species with empirical data and distribution
#this is pretty gross looking but not that complicated really.
#We loop through each item of the list (.l), which loops us through each species,
#where we make a ggplot figure for each species
newdat <- list(lai = seq(0, 20, length.out = 100))
pmap(.l = list(dat = weibull_models$data, 
               sp = weibull_models$Species,
               mod = weibull_models$model),
     .f = function(dat, sp, mod){ 
       ggplot(data = dat, aes(x = lai, y = prop_present)) + 
         geom_point() + 
         ggtitle(label = sp) +
         geom_line(data = data.frame(pred = predict(mod, newdata = newdat),
                                     lai = newdat$lai),
                   aes(y = pred, x = lai))
     })

```


Looking at the previous two panels, we can see that the distribution of recruits in FIA plots differ strongly between balsam fir and quaking aspen, and that our Weibull curves were able to represent them pretty well. As far as the parameters go, they look like this:

```{r}
print(dplyr::select(weibull_models, Species, shape, scale, location, adjust))
```

The shape parameter is the most important to determining whether the species has its highest or lowest recruitment at LAI = 0. You may need to manually set that for some species to get the right shape. Here, the curve-fitting algorithm got it right, but if it doesn't, you can modify the species_bounds variable in the script. 

This script can be used for any number of species, as long as they're in FIA. It would take a little work to adapt it to other plot networks, but it shouldn't be that difficult -- the main steps would remain the same. If no plot data is available, of course, using inherited parameters from other sites or similar species remains one of the easiest ways to get a model up and running so it can be calibrated. Let me know if you need any help with this script or NECN regeneration in general, at swflake@ncsu.edu. 